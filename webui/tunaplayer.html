<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8" />
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta names="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  </head>

  <script type="text/javascript" src="jquery.min.js"></script>
  <script type="text/javascript" src="jquery.jqote2.min.js"></script>
  <script type="text/javascript" src="tunaplayerdaemon.js"></script>
  <script type="text/javascript">


(function() {
  if (isMobile()) {
    document.write('<link rel="stylesheet" href="tunaplayer_n9.css"/>');
    document.write('<meta name="viewport" content="width=device-width, height=device-height, initial-scale=0.85, maximum-scale=0.85, user-scalable=0" />');

    visibleTracks = 600000;
    artistShortcutVisibleItems = 4;
  } else {
    window.resizeTo(825,520);
    artistShortcutVisibleItems = 7;
    document.write('<link rel="stylesheet" href="tunaplayer.css"/>');   
    document.write('<meta name="viewport" content="width=device-width, height=device-height, initial-scale=1.0, maximum-scale=1.0, user-scalable=0," />');
  }
})();

/* Global instance that contains the search results */
var searchResults = {};

/* Contains a precompiled qjote templates index by name */
var templates = {};

/* Amount of tracks visible in playlist view at a time */
var playlistVisibleItems = 6;

/* Currently visible top index, increased in granularity of playlistVisibleItems */
var playlistVisibleTopIndex = 0;

/**
View: ArtistSingleAlbum. 
Description: Index of topmost track.  
*/
var currentTrackIndex = 0;

/**
View: ArtistSingleAlbum
Description: Amount of visible tracks. Can not really be changed w/o refactoring the whole UI.
*/
var visibleTracks = 8;

/**
View: ArtistList
Description: How many artist shortcuts visible at @ time.
*/
var artistShortcutVisibleItems = isMobile() ? 4 : 7;

/**
Context: Global
Description: Data model for all the artists.
*/
var allArtists   = null;

/**
Context: Global
Description: Shadow for allArtists. Will contain updated "all artists" model.
*/
var allArtists_shadow = null;

/**
Context: Global
Description: Precalculated artist shortcuts ( 'A' -> { .. }, '0' -> { .. } )
*/
var artistShortcuts = null;

/**
Context: Global
Description: Shadow for precalculated artist shortcuts used to built temporary list that gets updated when appropriate.
*/
var artistShortcuts_shadow = null;

var artistAlbums = null;
var currentAlbum = null;
var currentAlbumTracks = null; 
var radioStations = null;
var radioStations_shadow = null;
var currentPlaylist = null;

/* This specifies the index of the item that is currently on left within the shortcut array, generally 0,7,14,.. */
var artistShortcutLPos = 0;
var artistShortcutOffset = 0;

var pageStack = new Array;

var ignorePositionReportsTimer = null;
var reportPlaybackPositionTimer = null;

/* Start index of leftmost visible art int artist albums view. Basically
 increases in granularity of xx */
var artistAlbumArtVisibleIndex = 0;

var playlistLongPressTimer = null;
var playerVolumeUpLongPressTimer = null;
var longPressTimer = null;

/* Amount of visible items in radio stations page */
var radioVisibleCount = isMobile() ? 128 : 6;
/* Currently visible item in radio stations page */
var radioVisibleStart = 0;

var userProfileList = null;

function playlistPlayTrackNow(id) {
  console.log("playlistPlayTrackNow: " + id);
  playlistLongPressTimer = null;
  playlistMoveTrackToTop(id);
  tunaPlayer.play(function(json) {
    if (json["status"] != "OK") {
      tunaPlayer.next();
    }
    if (!isMobile()) {
      closeView();
    }
  });
}

function playlistMoveTrackToTop(id) {
  console.log("playlistMoveTrackToTop: " + id);
  tunaPlayer.removeFromPlaylist(id, function(json) {
    if (json["status"] == "OK") { 
      tunaPlayer.addToPlaylistFront(id);
    }
  });
}

function playlistTrackMouseDown(object) {
  var id = object.getAttribute("data-track-id");

  if (!id || id.length < 1) {
    return;
  }

  if (playlistLongPressTimer) {
    clearTimeout(playlistLongPressTimer);
    playlistLongPressTimer = null;
  }
  playlistLongPressTimer = setTimeout(function() { playlistPlayTrackNow(id); }, 500);
}

function playlistTrackMouseUp(object) {
  var id = object.getAttribute("data-track-id");
  if (!id || id.length < 1) {
    return;
  }
  if (playlistLongPressTimer) {
    clearTimeout(playlistLongPressTimer);
    playlistLongPressTimer = null;
    playlistMoveTrackToTop(id);
  }
}

function playerControl(command, object) {
  if (command == "next") {
    tunaPlayer.next();
  } else if (command == "stop") {
    tunaPlayer.stop();
    playerUpdatePlaybackPosition({percents: 0});
  } else {
      mode = $("#player_button_playstop").attr("data-mode");
      if (mode == "play") {
        tunaPlayer.play();
      } else {
        tunaPlayer.stop();
        playerUpdatePlaybackPosition({percents: 0});
      }
  }
}

function playerVolumePressed(dir) {
  if (playerVolumeUpLongPressTimer) {
    clearTimeout(playerVolumeUpLongPressTimer);
    playerVolumeUpLongPressTimer = null;
  }

  playerVolumeUpLongPressTimer = setTimeout(function() { 
    playerVolumeAdjust(dir);
    playerVolumePressed(dir); 
    }, 500);
}

function playerVolumeReleased(dir) {
  clearTimeout(playerVolumeUpLongPressTimer);
  playerVolumeUpLongPressTimer = null;
  playerVolumeAdjust(dir);
}



/**
* Album Art searching functionality
*/
function searchAlbumArtSelect(object) {
  var id = object.getAttribute("data-albumart-id");
  if (id != undefined && id.length > 0) {
    tunaPlayer.selectAlbumArt(id);
  }
  /* Close the search view after selection is made. */
  closeView();
}

function handleSearchAlbumArtComplete() {
  console.log("handleSearchAlbumArtComplete");
  $("#search_album_arts_status").html("search complete");
}

function isMobile() {
  if (navigator.userAgent.toLowerCase().indexOf('nokian9') > -1)
    return true;

  if (screen.width < 500)
    return true;

  return false;
}

function isChrome() {
  return navigator.userAgent.toLowerCase().indexOf('chrome') > -1;
}

function setImage(json, objectId) {
  var art = json["album.artl"];
  if (art == undefined || art == null || art.length < 1) {
    art = json["album.arts"];
    if (art == null || art == undefined || art.length < 1) {  
      art = null;
    }
  }

  var o = document.getElementById(objectId);
  if (o != undefined && o != null) {
    if (art == null) {
      if (isChrome()) {
        /* Chrome can not handle this properly. Sadly so. */
        o.src = "bogus-image-not-found";
      } else {
        o.src = null;
      }
    } else { 
      o.src = art;
    }
  }
}

function openArtist(object, openedByView) {
  console.log("openArtist");
  var id = object.getAttribute("data-artist-id");
  if (id != undefined && id.length > 0) {
    openView(openedByView, 'artist_albums_container', object);
  } else {
    console.log("ERROR: No data-artist-id defined");
  }
}

function openAlbum(object, openedByWindow) {
  var id = object.getAttribute("data-album-id");
  if (id != undefined && id.length > 0) {
    var src = "notrelevant";
    if (object.tagName === "img") {
      src = object.getAttribute("src");
    }
 
    if (src == undefined || src == null || src.length < 1 || src === "bogus-image-not-found") {
      searchAlbumArt(object, openedByWindow); 
    } else {  
      tunaPlayer.getAlbum(id, function(json) { 
        if (json["args"]["items"].length > 0) {
          currentAlbum = json["args"]["items"][0];
          openView(openedByWindow, "artist_single_album_container", object);
        }
      });
    }
  }
}

/**
* Radio page methods
*/
function listenRadio(object) {
  var id = object.getAttribute("data-playlist-id");
  if (id != undefined && id.length) {
    tunaPlayer.addToPlaylistFront(id, function(json) {
      if (json["status"] == "OK") {
        tunaPlayer.play(function(json) {
          if (json["status"] != "OK") {
            tunaPlayer.next();
          }
        });
        openView('radio_container', 'player_container');
      }
    });
  }
}

/**
* Rotates radio stations within the radio stations page.
*/
function rotateRadioStations(direction) {
  console.log("rotateRadioStations: " + direction);
  var offset = radioVisibleCount;

  if (direction) {
    if (direction == "previous") {
      offset = -radioVisibleCount;
    } else {
      offset = radioVisibleCount;
    }
  }

  radioVisibleStart += offset;
  if (radioVisibleStart >= radioStations.length)
    radioVisibleStart = 0;
  if (radioVisibleStart < 0)
    radioVisibleStart = 0;

  renderView("radio_container");
}


/**
* Player/current playlist page methods.
*/
function playerPlaylistRemove(object) {
  var id = object.getAttribute("data-track-id");
  if (id && id.length > 0) {
    console.log("removeFromPlaylist: " + id);
    tunaPlayer.removeFromPlaylist(id, function(json) {
      if (json["status"] == "OK") {
        // TODO: If playlist is empty -> closeView
      }
    });
  }
}

function playerPlaylistShuffle(object) {
  tunaPlayer.shufflePlaylist();
}

function playerPlaylistClear(object) {
  tunaPlayer.clearPlaylist();
  closeView();
}

/**
* Player page methods.
*/
function playerOpened() {
  var elem = document.getElementById("player_page");  
  if (elem == undefined) {
    return false;
  }
  return true;
}

function isTrue(object) {
  if (typeof object == "boolean")
    return object;
  if (typeof object == "string")
    return (object.toLowerCase() == "true");
  return false;
}

function isFalse(object) {
  if (isTrue(object))
    return false;
  return true;
}


function playerUpdateButtonsFromCache() {
  if (tunaPlayer.cachedPlaybackControls) {
    playerUpdateButtons(tunaPlayer.cachedPlaybackControls);
  }
}

function playerUpdateButtons(json) {
  console.log("PLAYER: update_buttons: " + JSON.stringify(json));

  updateMainShortcutVisibility();

  if (!playerOpened()) {
    return;
  }

  /* JSON contains a map like: 
    ---------
    {"mute":false,"next":false,"pause":false,"play":false,"seek":false,"stop":false,"unmute":false}
  */
  var playstopText;
  $("#player_button_playstop").addClass("button_disabled");
  if (isTrue(json.play) && isFalse(json.stop)) {
    playstopText = "&#x25b7;";
    $("#player_button_playstop").removeClass("button_disabled");
    $("#player_button_playstop").attr("data-mode", "play");
  }
  if (isFalse(json.play) && isTrue(json.stop)) {
    playstopText = "&#x25A2;";
    $("#player_button_playstop").removeClass("button_disabled");
    $("#player_button_playstop").attr("data-mode", "stop");
  }
  if (isFalse(json.play) && isFalse(json.pause)) {
    $("#player_button_playstop").attr("data-mode", "");
    playstopText = "";
  }
  $("#player_button_playstop_inner").html("<center><b>" + playstopText + "</b></center>");

  if (isTrue(json.next)) {
    $("#player_button_next").removeClass("button_disabled");
  } else {
    $("#player_button_next").addClass("button_disabled");
  }
}

function playerUpdatePlaybackPosition(json) {
/*console.log("playerUpdatePlaybackPosition");*/
  if (ignorePositionReportsTimer != null)
    return;

  var position_ctrl = document.getElementById("player_playback_position_text");
  var position = parseInt(json.position);
  if (position_ctrl != undefined && json.position != undefined) {
    var mins;
    var secs;

    hrs = Math.floor(position / 3600);
    if (hrs > 0) {
      // Take the "hours" away before calculating minutes.
      position = (position - (hrs * 3600));
      if (parseInt(position) < 0) {
        position = 0;
      }
    } 
    mins = Math.floor(position / 60);
    secs = position % 60;

    if (hrs > 0 && hrs < 10)
      hrs = "0" + hrs;
    else if (hrs < 1)
      hrs = "";

    if (hrs > 0) {
      if (mins < 10) {
        mins = "0" + mins;
      }
    }

    if (secs < 10)
      secs = "0" + secs;

    if (position != undefined) {
      if (hrs.length) {
        position_ctrl.innerHTML = hrs + ":" + mins + ":" + secs;
      } else {
        position_ctrl.innerHTML = mins + ":" + secs;
      }
    } else {
      position_ctrl.innerHTML = "";
    }
  } else if (position_ctrl != undefined) {
    position_ctrl.innerHTML = "";
  }

  var seek_ctrl = document.getElementById("player_playback_position");
  if (seek_ctrl != undefined) {
    seek_ctrl.value = parseInt(json["percents"]);
  }
}

function playerUpdateCurrentPlaylist(json) {

  var oldPlaylistItemCount = currentPlaylist ? currentPlaylist["args"]["items"].length : 0;

  if (isMobile()) {
    /* on mobile(s), the playlist is placed below the actual player */
    currentPlaylist = json;
    /* limit the playlist length 100 on mobile.. */
    if (currentPlaylist.args.items.length > 100) {
      currentPlaylist.args.items.length = 100;
    }
    if (isForegroundView("player_container")) {
      renderView("player_container", {"scrollToTop": false } );
    }
  } else {
    currentPlaylist = json;
    var playlist_page = document.getElementById("player_current_playlist_page");
    if (playlist_page != undefined) {
      if (playlistVisibleTopIndex >= currentPlaylist["args"]["items"].length) {
        playlistVisibleTopIndex = 0;
      }
      renderView("player_current_playlist");
    }
  }

  var playlistItemCount = currentPlaylist ? currentPlaylist["args"]["items"].length : 0;
  if (playlistItemCount > 0 && playlistItemCount != oldPlaylistItemCount && !isForegroundView('player_container')) {
    note.show("Playlist has <b>" + playlistItemCount + "</b> tracks", 5000);
  }

  updateMainShortcutVisibility();
}

/**
* Updates the visibility of the player 
*/
function updateMainShortcutVisibility() {

  /*
  * Update the visibility of the "Player" launcher. It should be visible only
  * when there is playable content (playlist has entries etc.)
  */
  var hidePlayer = false;
  var plItems = currentPlaylist ? currentPlaylist["args"]["items"].length : 0;
  if (plItems === 0) {
    if (tunaPlayer.cachedPlaybackControls) {
      if (isFalse(tunaPlayer.cachedPlaybackControls.stop)) {
        hidePlayer = true;
      }
    }
  }

  if (hidePlayer === true) {
    $("#player_launcher").addClass("hidden"); 
  } else {
    $("#player_launcher").removeClass("hidden");
  }
}

function startWaitLongMousePress(object, callerView) {
  longPressTimer = setTimeout(function() { 
    longPressTimer = null;
    albumCommand("play", object, callerView ? callerView : 'artist_albums_container'); 
    }, 750);
}

function stopWaitLongMousePress(object, execCommand) {
  if (longPressTimer) {
    clearTimeout(longPressTimer);
    longPressTimer = null;
    if (execCommand) {
      execCommand();
    }
  }
}

function searchAlbumArt(object, caller_page) {
  var albumId = $(object).attr("data-album-id");
  if (albumId != undefined && albumId.length > 0 && caller_page != undefined && caller_page.length > 0) {
    resetDownloadedAlbumArtItems();
    console.log("Starting album art search");
    tunaPlayer.searchAlbumArt(albumId, function(json) {
      if (json["status"] != "OK") { 
        closeView();
      }
    });

    /* Open the window that will show the results.. */
    openView(caller_page, 'search_album_arts', albumId);
  } else {
    console.log("Failed to start albumart search. No Id");
  }
}



function clearIgnorePositionReports() {
  ignorePositionReportsTimer = null;
}

function controlPlaybackPosition(object) {
  tunaPlayer.seekPercents(object.value);
  reportPlaybackPositionTimer = null;
}

function playerPlaybackPositionChanged(object) {

  if (ignorePositionReportsTimer != null) {
    clearTimeout(ignorePositionReportsTimer);
    ignorePositionReportsTimer = null;
  }

  if (reportPlaybackPositionTimer != null) {
    clearTimeout(reportPlaybackPositionTimer);
    reportPlaybackPositionTimer = null; 
  }
  reportPlaybackPositionPimer = setTimeout(function() { controlPlaybackPosition(object) }, 250);
  ignorePositionReportsTimer = setTimeout(clearIgnorePositionReports, 500);
}

function playerUpdatePlaybackTrackFromCache() {
  playerUpdatePlaybackTrack(tunaPlayer.cachedPlaybackTrack);
}

function playerUpdatePlaybackAlbumFromCache() {
  playerUpdatePlaybackAlbum(tunaPlayer.cachedPlaybackAlbum);
}

function playerUpdatePlaybackAlbum(json) {
  console.log("playerUpdatePlaybackAlbum: " + JSON.stringify(json));

  if (!playerOpened()) {
    return;
  }

  if (!json || json == undefined) {
    img = document.getElementById("player_playing_album_image");
    if (img) {
      img.removeAttribute("src");
    }

    $("#player_playing_track").html("");
    $("#player_playing_artist_album").html("");

    // We will automagically close the player view once there
    // is nothing to play..
    closeView();

    return;
  }

  setImage(json, "player_playing_album_image");

  if (json["id"]) {
    $("#player_playing_album_image").attr("data-album-id", json["id"]);
  }
  if (json["artist.id"]) {
    $("#player_playing_album_image").attr("data-artist-id", json["artist.id"]);
  }
}

function playerUpdatePlaybackTrack(json) {
/*  console.log("playerUpdatePlaybackTrack: " + JSON.stringify(json));*/

  if (!json)
    return;

  if (!playerOpened()) {
    note.showNowPlaying(json);
    return;
  }
  $("#player_playing_track").attr("data-track-id", (json.id != undefined ? json.id : ""));
  $("#player_playing_track").html((json.name != undefined ? json.name.toLowerCase() : ""));

  var len = parseInt(json["len"]);
  if (len < 1) {
    console.log("TODO: Hide the progress indicator");
  }
  
  var albumartist = "";
 
  if (json["album.artist.name"])
    albumartist += json["album.artist.name"];
  if (json["album.name"]) {
    if (albumartist.length) 
      albumartist += " - ";
    albumartist += json["album.name"]
  }
    
  $("#player_playing_artist_album").html(albumartist.toLowerCase());
  
  setImage(json, player_playing_artist_album);

  $("#player_playing_album_image").attr("data-album-id", json["album.id"]);
}

function trackClicked(trackDiv) {
  var trackId = trackDiv.getAttribute("data-track-id");
  console.log("track: " + trackId + " clicked");

  if ($(trackDiv).hasClass("artist_single_album_track_selected"))
    $(trackDiv).removeClass("artist_single_album_track_selected");
  else
    $(trackDiv).addClass("artist_single_album_track_selected");
}

function rotateTracks(callerObject) {

  if (currentAlbumTracks["items"].length <= visibleTracks)
    return;

  currentTrackIndex += visibleTracks;
  if (currentTrackIndex >= currentAlbumTracks["items"].length)
    currentTrackIndex = 0;

  var visibleFirst = currentTrackIndex;
  var visibleLast = currentTrackIndex + visibleTracks;

  console.log("rotateTracks: visible-range " + visibleFirst + " -> " + visibleLast);

  $(".artist_single_album_track").each(function(index, object) {
    if (index >= visibleFirst && index < visibleLast) {
      $(object).css("display", "block");
    } else {
      $(object).css("display", "none");
    }
  });
}

function albumCommand(command, div, caller) {
  var albumId = div.getAttribute("data-album-id");

  var selectedTracks = new Array;

  $(".artist_single_album_track_selected").each(function(index, object) {
    selectedTracks.push(object.getAttribute("data-track-id"));
  });

  // If nothing selected -> assume one likes to give
  if (selectedTracks.length == 0) {
    if (command == "queue") {
      tunaPlayer.addToPlaylist(albumId);
    } else {
      /* Firstly, make sure all tracks in given album does not exists in playlist anymore */
      tunaPlayer.removeFromPlaylist(albumId);
      tunaPlayer.addToPlaylistFront(albumId);
      tunaPlayer.play(function(json) {
        if (json["status"] != "OK") {
          // NOK -> Already playing, just move first newly added track.
          tunaPlayer.next();
        }
      });
      if (caller != undefined) {
        openView(caller, 'player_container');
      }
    }
  } else {
    if (command == "queue") {
      for (var i=0;i<selectedTracks.length;i++) {
        tunaPlayer.addToPlaylist(selectedTracks[i]);
      }
    } else {
      /* In reverse order as items are put in front of the playlist one-by-one. */
      for (var i=selectedTracks.length-1;i>=0;i--) {
        tunaPlayer.removeFromPlaylist(selectedTracks[i]);
        tunaPlayer.addToPlaylistFront(selectedTracks[i]);
      }
      tunaPlayer.play(function(json) {
        if (json["status"] != "OK") {
          // NOK -> Already playing, just move to this track.
          tunaPlayer.next();
        }
      });
    }
  }

  // Once completed -> remove selections
  $(".artist_single_album_track").each(function(index, object) {
    $(object).removeClass("artist_single_album_track_selected");
  });
}

function artistCommand(command, div, caller) {
  var artistId = div.getAttribute("data-artist-id");
  console.log("artistCommand: " + command + " " + artistId);
  if (artistId != undefined && artistId.length > 0) {
    if (command == "queue") {
      tunaPlayer.addToPlaylist(artistId);
    } else if (command == "play") {
      tunaPlayer.removeFromPlaylist(artistId);
      tunaPlayer.addToPlaylistFront(artistId);
      tunaPlayer.play(function(json) {
        if (json["status"] != "OK") {
          // Play fails if already playing a track. On that case the
	  // newly interested artist is first track in playlist.
          tunaPlayer.next();
        }
      });

      if (caller != undefined) {
        openView(caller, 'player_container');
      }
    }
  }
}

function rotateAlbums(object) {

  var index = artistAlbumArtVisibleIndex + 6;
  index = index % artistAlbums.length;
  if (index < 6)
    index = 0;
  artistAlbumArtVisibleIndex = index;

  console.log("-> rotateAlbums: " + index);

  renderView('artist_albums_container');
}

function seekActiveArtistShortcutPage(offset) {
  artistShortcutOffset = 0;

  offset = fixOffset(offset);

  if (offset < 0) {
    artistShortcutLPos -= artistShortcutVisibleItems;
    if (artistShortcutLPos < 0)
      artistShortcutLPos = 0;
  } else if (offset > 0) {
    var rightmostIndex = artistShortcutLPos + artistShortcutVisibleItems;
    if (getArtistShortcutCount() > rightmostIndex)
      artistShortcutLPos = rightmostIndex;
    else
      return;
  }
  renderView("artists_container");
}



function __printPageStack(info) {

  console.log("-------------------------------------------");
  console.log("-- PAGESTACK after " + info);
  for (var i=0;i<pageStack.length/2;i++) {
    console.log(" " + pageStack[i*2] + " -> " + pageStack[i*2+1]);
  }
  console.log("-------------------------------------------");
}

function pageStackPush(pageId1, pageId2) {
  if (pageId1 != undefined) {
    pageStack.push(pageId1);
  } 
  if (pageId2 != undefined) {
    pageStack.push(pageId2);
  }
  __printPageStack("push");
}

function pageStackPop() {
  return pageStack.pop();
  __printPageStack("pop");
}

function currentShortcutIndex() {
  return artistShortcutLPos + artistShortcutOffset;
}


/*
 NOTE: This might adjust the LPos eventually.
*/
function createArtistShortcutBar() {

  var initData = {};

  initData["selectedIndex"] = artistShortcutOffset;
  initData["leftVisible"] = artistShortcutLPos == 0 ? false : true;
  initData["items"] = new Array();

  var artistShortcutCount = getArtistShortcutCount();
  var visibleItems = artistShortcutVisibleItems;
  for (var i=artistShortcutLPos;i<artistShortcutCount && visibleItems > 0;i++) {
    var ch = artistShortcuts[i][0]["name"].charAt(0).toLowerCase();
    var item = {"index": i, "key": ch };
    initData["items"].push(item);
    --visibleItems;
  }

  initData["rightVisible"] = (artistShortcutCount - artistShortcutVisibleItems) > artistShortcutLPos ? true : false;

  var html = $.jqote(templates.tmpl_artist_shortcutbar, initData);

  return html;
}


function createArtistListbox() {

  if (!allArtists || allArtists.length < 1) {
    return "<p>(No Items)</p>";
  }

  var initData = {};
  var html;

  if (isMobile()) {
    initData["items"] = artistShortcuts;
    html = $.jqote(templates.tmpl_artist_listbox, initData);
  } else {
    var itemsToShow = 6;
    var uiTopIndex = getArtistShortcutUiIndex(currentShortcutIndex());
    var uiBottomIndex = uiTopIndex + itemsToShow - 1;

    initData["topIndex"] = uiTopIndex;
    initData["bottomIndex"] = uiBottomIndex;
    initData["items"] = getShortcutArtists(currentShortcutIndex());

    html = $.jqote(templates.tmpl_artist_listbox, initData);
  }

  return html;
}


function createArtistsPageContent(rootElement) {
  var html;

  if (isMobile()) {
    html = createArtistListbox();
  } else {
    var shortcutBarHtml = createArtistShortcutBar();
    var separatorHtml = '<div style="clear: both;"></div>';
    var listboxHtml = createArtistListbox();

    html = shortcutBarHtml + separatorHtml + listboxHtml;
  }

  return html;
}  


function createArtistAlbumsPageContent(artistDefinition) {
  if (artistAlbums == null || artistAlbums == undefined) {
    console.log("artistAlbums not ready yet -> leaving");
    return;
  }
  var initData = {};
  var imagesToShow = isMobile() ? 600000 : 6;

  initData["items"] = artistAlbums;
  initData["firstVisible"] = artistAlbumArtVisibleIndex;
  initData["lastVisible"] = artistAlbumArtVisibleIndex + imagesToShow;
  initData["rotatePossible"] = artistAlbums.length > imagesToShow;

  var html = $.jqote(templates.tmpl_artist_albums, initData);

  return html;
}

function createArtistSingleAlbumPageContent(albumId) {
  var initData = {};

  if (isMobile())
    visibleTracks = 600000;

  initData["firstTrack"] = currentTrackIndex;
  initData["lastTrack"] = currentTrackIndex + visibleTracks;
  initData["items"] = currentAlbumTracks["items"];
  initData["tracklisthtml"] = createArtistSingleAlbumTrackList();
  initData["rotatePossible"] = currentAlbumTracks["items"].length > visibleTracks;
  initData["album"] = currentAlbum;

  var html = $.jqote(templates.tmpl_artist_single_album, initData);
  
  return html;
}

function createArtistSingleAlbumTrackList() {
  var initData = {};

  if (isMobile())
    visibleTracks = 600000;

  initData["firstTrack"] = currentTrackIndex;
  initData["lastTrack"] = currentTrackIndex + visibleTracks;
  initData["items"] = currentAlbumTracks["items"];
  var html = $.jqote(templates.tmpl_artist_single_album_tracklist_content, initData);
console.log("DEBUG: " + html);
  return html;
}

function createPlayerPageContent() {
  var initData = {};

  if (isMobile()) {
    initData["items"] = currentPlaylist["args"]["items"];
  }

  var html = $.jqote(templates.tmpl_player_content, initData);

  return html;
}

function createPlayerCurrentPlaylistPageContent() {
  var initData = {};
  
  if (isMobile())
    playlistVisibleItems = 600000;

  initData["items"] = currentPlaylist["args"]["items"];
  initData["firstItem"] = playlistVisibleTopIndex;
  initData["lastItem"] = playlistVisibleTopIndex + playlistVisibleItems;
  initData["rotatePossible"] = currentPlaylist["args"]["items"].length > playlistVisibleItems;

  var html = $.jqote(templates.tmpl_player_current_playlist, initData);

  return html;
}

function rotatePlaylistTracks() {
  playlistVisibleTopIndex += playlistVisibleItems;
  if (playlistVisibleTopIndex >= currentPlaylist["args"]["items"].length)
    playlistVisibleTopIndex = 0;

  renderView("player_current_playlist");
}

function createRadioPageContent() {

  var initData = {};
  initData["items"] = radioStations;
  initData["firstVisible"] = radioVisibleStart;
  initData["lastVisible"] = radioVisibleStart + radioVisibleCount;
  initData["rotatePossible"] = (radioStations.length > radioVisibleCount);

  var html = $.jqote(templates.tmpl_radio_stations, initData);

  return html;
}

var downloadedAlbumArtItems = null;

function resetDownloadedAlbumArtItems() {
  downloadedAlbumArtItems = new Array;
}

function handleAlbumArtDownloaded(json, norender) {
  if (!downloadedAlbumArtItems) {
    console.log("ERROR: Not expecting to receive album art download response");
    return;
  }

  console.log("ALBUMART-ITEM: " + JSON.stringify(json));

  if (isForegroundView('search_album_arts')) {
    downloadedAlbumArtItems.push(json);
    if (norender == undefined) {
      renderView('search_album_arts');
    }
  }
}

function createSearchAlbumArtsPageContent() {
  var initData = {};

  initData["items"] = downloadedAlbumArtItems;

  var html = $.jqote(templates.tmpl_album_art_search, initData);

  return html;
}

function createPlaylistContainerPageContent() {
  tunaPlayer.playPlaylist("Random tracks");
  openView("root", "player_container");
}

function createRecentAlbumsPageContent(json) {
  var initData = {};

  initData["items"] = json["items"];

  var html = $.jqote(templates.tmpl_recent_albums, initData);

  return html;
}

/**
* SearchContext is main object that is responsible of making the searches
* towards the tunadaemon.
*/
var searchContext = {
  results: {},
  triggerTimer: null,
  triggerTimeout: 500,
  inProgress: false,
  pending: false,
  criteria: "",

  clear: function() {
    results = {};
  },

  /* Starts to execute the search operation */
  start: function() {
    searchContext.pending = false;
    var elem = document.getElementById("searchcriteria");
    if (elem) {
      searchContext.execute(elem.value);
    }
  },

  /* Called if/when user has typed something to the search criteria input box. */
  criteriaChanged: function(inp) {
    clearTimeout(searchContext.triggerTimer);
    if (inp.value.length <= 1) {
      searchContext.criteria = "";
      return;
    }

    searchContext.triggerTimer = setTimeout(function() { 
      searchContext.triggerTimer = null;
      searchContext.start();
    }, searchContext.triggerTimeout);  
  },

  /* Private function: Performs the actual search. */
  execute: function(criteria) {
    console.log("executeSearch(" + criteria + ")");
    if (searchContext.inProgress) {
      searchContext.pending = true;
      return;
    }

    searchContext.inProgress = true;
    tunaPlayer.searchArtist(criteria, function(json) { 
      searchContext.results["artists"] = json["args"].items;
      tunaPlayer.searchAlbum(criteria, function(json) {
        searchContext.results["albums"] = json["args"].items;
        tunaPlayer.searchTrack(criteria, function(json) {
          searchContext.criteria = criteria;
          searchContext.results["tracks"] = json["args"].items;
          searchContext.inProgress = false;
          searchViewData.reset();
          renderView("search_container", {"renderHint": "resultsonly", "renderContext": searchContext.results } );
          if (searchContext.pending) {
            searchContext.startSearch();
          }
        });
      }); 
    });
  }
};

/**
* Contains a definition of the data and methods used to manage contents within the search
* view (artists, albums, tracks and visible stuff in related).
*/
var searchViewData = {
  artistTopIndex: 0,
  albumTopIndex: 0,
  trackTopIndex: 0,
  artistItems: 0,
  albumItems: 0,
  trackItems: 0,
  visibleArtistItems: 6,
  visibleAlbumItems: 3,
  visibleTrackItems: 3,
  cachedResults: undefined,

  reset: function() {
    if (isMobile())
      return;

    searchViewData.cachedResults = undefined;
    searchViewData.artistTopIndex = 0;
    searchViewData.albumTopIndex = 0;
    searchViewData.trackTopIndex = 0;
    searchViewData.artistItems = 0;
    searchViewData.albumItems = 0;
    searchViewData.trackItems = 0;
  },

  rotateArtists: function() {
    searchViewData.artistTopIndex += searchViewData.visibleArtistItems;
    if (searchViewData.artistTopIndex >= searchViewData.artistItems) {
      searchViewData.artistTopIndex = 0;
    }
    renderView("search_container", {renderHint: "resultsonly"});
  },

  rotateAlbums: function() {
    searchViewData.albumTopIndex += searchViewData.visibleAlbumItems;
    if (searchViewData.albumTopIndex >= searchViewData.albumItems) {
      searchViewData.albumTopIndex = 0;
    }
    renderView("search_container", {renderHint: "resultsonly"});
  },
 
  rotateTracks: function() {
    searchViewData.trackTopIndex += searchViewData.visibleTrackItems;
    if (searchViewData.trackTopIndex >= searchViewData.trackItems) {
      searchViewData.trackTopIndex = 0;
    }
    renderView("search_container", {renderHint: "resultsonly"});
  }
}

function isMapEmpty(map) {
  for (var key in map) {
    if (map.hasOwnProperty(key)) {
      return false;
    }
  }
  return true;
}

function createSearchResultsContent(json) {
  if (isMapEmpty(json)) {
    if (searchViewData.cachedResults != undefined) {
      json = searchViewData.cachedResults;
    }
  } else {
    searchViewData.cachedResults = json;
  }

  var artists = json["artists"];
  var albums = json["albums"];
  var tracks = json["tracks"];

  if (!isMobile()) {
    json["artistTop"] = searchViewData.artistTopIndex;
    json["albumTop"] = searchViewData.albumTopIndex;
    json["trackTop"] = searchViewData.trackTopIndex;
    json["artistBottom"] = searchViewData.artistTopIndex + searchViewData.visibleArtistItems;
    json["albumBottom"] = searchViewData.albumTopIndex + searchViewData.visibleAlbumItems;
    json["trackBottom"] = searchViewData.trackTopIndex + searchViewData.visibleTrackItems;

    searchViewData.artistItems = artists ? artists.length : 0;
    searchViewData.albumItems = albums ? albums.length : 0;
    searchViewData.trackItems = tracks ? tracks.length : 0;

    json["artistItemCount"] = searchViewData.artistItems;
    json["albumItemCount"] = searchViewData.albumItems;
    json["trackItemCount"] = searchViewData.trackItems;

    json["artistRotatePossible"] = searchViewData.artistItems > searchViewData.visibleArtistItems;
    json["albumRotatePossible"] = searchViewData.albumItems > searchViewData.visibleAlbumItems;
    json["trackRotatePossible"] = searchViewData.trackItems > searchViewData.visibleTrackItems;

/*    console.log("SearchResultData: " + JSON.stringify(json));*/
  }

  var html = $.jqote(templates.tmpl_search_results, json);

  return html;
}

function createSearchHeaderContent(json) {
/*  json["value"] = searchContext.criteria;*/

  var html = $.jqote(templates.tmpl_search_header, json);

  return html;
}

function renderView(viewId, arg) {
  var targetObject = document.getElementById(viewId);
  if (!targetObject) {
    console.log("ERROR: Unable to locate object: " + viewId);
    return;
  }
    
  var renderHint = arg ? arg.renderHint || "no" : undefined;
  var renderContext = arg ? arg.renderContext || {} : undefined;
  var initData = arg && arg.initData != undefined ? arg.initData : {};
  var scrollToTop = arg && arg.scrollToTop != undefined ? arg.scrollToTop : true;

  if (viewId == "artists_container") { 
    if (renderHint == "artistlistOnly") {
      var lbContainer = document.getElementById("artist_listbox_container");
      if (lbContainer != undefined) {
        lbContainer.innerHTML = createArtistListbox();
      }
    } else {
      targetObject.innerHTML = createArtistsPageContent();
      updateShortcutVisiblePageText();
    }
  } else if (viewId == "artist_albums_container") {
    targetObject.innerHTML = createArtistAlbumsPageContent(renderContext);
  } else if (viewId == "artist_single_album_container") {
    targetObject.innerHTML = createArtistSingleAlbumPageContent(initData.getAttribute('data-album-id'));
  } else if (viewId == "radio_container") {
    targetObject.innerHTML = createRadioPageContent();
  } else if (viewId == "player_container") {
    targetObject.innerHTML = createPlayerPageContent();
    playerUpdateButtonsFromCache();
    playerUpdatePlaybackTrackFromCache();
    playerUpdatePlaybackAlbumFromCache();
    processVolumeChanged();
  } else if (viewId == "player_current_playlist") {
    targetObject.innerHTML = createPlayerCurrentPlaylistPageContent();
  } else if (viewId == "search_album_arts") {
    targetObject.innerHTML = createSearchAlbumArtsPageContent();
  } else if (viewId == "playlist_container") {
    targetObject.innerHTML = createPlaylistContainerPageContent();
  } else if (viewId == "recent_albums_container") {
    targetObject.innerHTML = createRecentAlbumsPageContent(renderContext["args"]);
  } else if (viewId == "search_container") {
    var search_header_container = document.getElementById("search_header");
    var search_result_container = document.getElementById("search_results");
    if (!search_header_container && !search_result_container) {
      targetObject.innerHTML = '<div id="search_header"></div><div id="search_results"></div>'
    }
    search_header_container = document.getElementById("search_header");
    search_result_container = document.getElementById("search_results");

    if (renderHint !== "resultsonly") {
      search_header_container.innerHTML = createSearchHeaderContent(renderContext);
    }
    if (search_result_container)
      search_result_container.innerHTML = createSearchResultsContent(renderContext);
/*console.log("GENERATED HTML=" + search_result_container.innerHTML);*/
  }

  if (isMobile() && targetObject.innerHTML.length > 0) {
    new Swipe(targetObject, function(event) { if (event === "move.previous") closeView(); } );

    if (scrollToTop === true) {
      window.scrollTo(0,0);
    }
  }
}

function isForegroundView(id) {
  if (pageStack.length < 2) {
    return false;
  }

  if (pageStack[pageStack.length-1] === id) {
    return true;
  }
  return false;
}

function toggleClassById(id, _class) {
  $("#" + id).toggleClass(_class);
}

/**
* oldId: Identifier of the "page" where transition begins
* newId: Identifier of the "page" where to the transition ends.
* initData: Possible context specific data to be passed for the renderer.
*/
function openView(oldId, newId, initData) {

  if (newId == "player_container") {
    tunaPlayer.enablePlaybackPositionEvents();
  }
  if (oldId == "player_container") {
    tunaPlayer.disablePlaybackPositionEvents();
  }

  console.log("OPEN '" + newId + "' FROM '" + oldId + "'");

  $("#" + oldId).addClass("div_hidden");
  $("#" + oldId).removeClass("tile_opened");

  $("#" + newId).removeClass("div_hidden");
  $("#" + newId).addClass("tile_opened");

  /* Cache the current page content. Will be restored in closeView if cached previously. */
  if (oldId != "root") {
    var elem = document.getElementById(oldId);
    if (elem) {
      elem.setAttribute("data-cached-content", elem.innerHTML);
      elem.setAttribute("data-cached-y-position", window.pageYOffset);
      elem.innerHTML = "";
    }
  } else {
    console.log("OPEN '" + newId + "' from ROOT");
  }

  /* Page stack holds pairs. -> Thus when popping we get first the page to close and then the page to open 
     This effectively allows non-deterministic transitions between views thus that "back" from a view returns user to some other
     view than where the original transition started. Confusing but yet useful sometimes.
  */
  pageStackPush(oldId, newId);
  loadViewContent(oldId, newId, initData, function() { 
     renderView(newId, {"initData": initData}); 
    }
  );
}

function closeAllViews() {
  var more = false;

  do {
    more = closeView();
  } while (more);
}

function closeView() {
  var closeId = pageStackPop();
  var openId = pageStackPop();

  if (closeId == undefined || openId == undefined) {
    return false;
  }

  console.log("CLOSE " + closeId + " in order to OPEN " + openId);

  if (openId != undefined) {

    if (openId == "player_container") {
      tunaPlayer.enablePlaybackPositionEvents();
    }

    var object = document.getElementById(openId);
    if (object) {
      var ypos = object.getAttribute("data-cached-y-position");
      var cachedContent = object.getAttribute("data-cached-content");
      if (cachedContent && cachedContent.length) {
        object.innerHTML = cachedContent;
        object.removeAttribute("data-cached-content");
        if (ypos) {
          window.scrollTo(0, ypos);
          object.removeAttribute("data-cached-y-position");
        }
      }
      $(object).removeClass("div_hidden");
      $(object).addClass("tile_opened");
      if (openId == "search_container" && closeId != "root") {
        /* This is the case when returning BACK to search view from a view opened from the search view -> restore the search criteria (content otherwise OK already). */
        var selem = document.getElementById("searchcriteria");
        if (selem) {
          selem.setAttribute("value", searchContext.criteria);
          if (document.selection)
            document.selection.empty();
          selem.setSelectionRange(selem.value.length, selem.value.length);
          selem.focus();
        }
      }
    } else {
      // Likely the main view -> update the visibility of the main shortcuts.
      updateMainShortcutVisibility();
    }
  }
  if (closeId != undefined) {
    if (closeId == "player_container") {
      tunaPlayer.disablePlaybackPositionEvents();
    }
    var object = document.getElementById(closeId);
    if (object != undefined) {
      object.innerHTML = ""; /* Clear the contents of the page to be closed so that it wont affect */
      $(object).addClass("div_hidden");
      $(object).removeClass("tile_opened");
    }
  } 

  return true;
}


function loadArtistAlbums(object, renderer) {
  var id = object.getAttribute("data-artist-id");
  if (id != undefined && id.length > 0) {
    tunaPlayer.getArtistAlbums(id, function(json) {
      console.log("All artist " + id + " albums loaded");
      if (json["status"] == "OK") {
        artistAlbums = json["args"]["items"];
        if (renderer) renderer();
      } else {
        alert("Failed to load artist albums");
      }
    });
  } else {
    console.log("ERROR: loadArtistAlbums no ID");
  }
}

function loadViewContent(oldid, newid, initData, renderer) {

  console.log("LOADVIEWCONTENT to OPEN view '" + newid + "' FROM '" + oldid + "'");

  /* When set to true, page will not be rendered at the end of this function
     but will be done "later on" when data is available. */
  var delayedRender = false;

  if (newid == 'artist_single_album_container' || oldid == 'search_album_arts') {
    var id = null;
    if (newid == 'artist_single_album_container') {
      var index = $(initData).attr("data-album-index");
      if (index != undefined) {
        index = parseInt(index);
        if (index >= 0 && index < artistAlbums.length) {
          currentAlbum = artistAlbums[index];
        }
      } else {
        id = $(initData).attr("data-album-id");
      }
    }
    if (!id) {
      id = initData.getAttribute("data-album-id");
    }
    currentTrackIndex = 0;

    delayedRender = true;
    tunaPlayer.getAlbumTracks(id, function(json) {
      if (json["status"] == "OK") {
/*console.log("ALBUMTRACKS: " + JSON.stringify(json));*/
        currentAlbumTracks = json["args"];
        if (renderer != undefined) {
          renderer();
        }
      } else {
        alert("Failed to load album tracks");
      }
    });
  }
  if (newid == "artist_single_album_container" && (oldid == "artist_albums_container" || oldid == "search_container")) {
    currentTrackIndex = 0;
  }
  if (newid == "player_current_playlist") {
    delayedRender = true;
    playlistVisibleTopIndex = 0;
    var count = undefined;
    if (isMobile())
      count = 100;
    tunaPlayer.getCurrentPlaylist(function(json) {
      if (json["status"] == "OK") {
        currentPlaylist = json;
        if (renderer) {
          renderer();
        }
      } else { 
        console.log("ERROR: Failed to get playlist: " + JSON.stringify(json));
      }
    }, count);
  }
  if (newid == 'artist_albums_container') {
    artistAlbumArtVisibleIndex = 0;
    loadArtistAlbums(initData, renderer);
    delayedRender = true;
  }
  if (newid == "artists_container") {
    upgradeDatabase();
  }
  if (newid == "radio_container") {
    upgradeDatabase();
  }
  if (newid == "recent_albums_container") {
    delayedRender = true;
    tunaPlayer.getRecentAlbums(isMobile() ? 20 : 3, function(json) {
      console.log("RECENTALBUMS: " + JSON.stringify(json)); 
      if (json["status"] == "OK") {
        renderView(newid, {"renderContext": json});
      } else {
        closeView();
      }
    });
  }
  if (newid == "search_container") {
    if (oldid == "root") {
      searchContext.results = {};
      searchContext.criteria = "";
      searchViewData.cachedResults = {};
      console.log("OPEN SEARCH VIEW from ROOT");
    }
  }
  if (isMobile()) {
    if (newid == "player_container") {
      delayedRender = true;
      playlistVisibleTopIndex = 0;
      tunaPlayer.getCurrentPlaylist(function(json) {
        if (json["status"] == "OK") {
          currentPlaylist = json;
          if (renderer) {
            renderer();
          }
        } else { 
          console.log("ERROR: Failed to get playlist: " + JSON.stringify(json));
        }
      }, 100);
    }
  }
  

  if (!delayedRender && renderer) {
    renderer();
  }
}

function upgradeDatabase() {
  if (allArtists_shadow && artistShortcuts_shadow && radioStations_shadow) {

    console.log("Taking new database into use");

    allArtists = allArtists_shadow;
    allArtists_shadow = null;

    artistShortcuts = artistShortcuts_shadow;
    artistShortcuts_shadow = null;

    radioStations = radioStations_shadow;
    radioStations_shadow = null;
  }
}

function handleKeyPress(e) {
  console.log("KEYPRESS: " + e.toString() + "(raw: " + e + ")");
  if (e.charCode == 113 /* q */) {
    closeView();
  }
}

String.prototype.trim = function() {
  return this.replace(/^\s*/, "").replace(/\s*$/, "");
}

function filterArtistName(str) {
  return str.trim().toLowerCase();
}

function initArtistShortcuts(list, inittype) {
  for (var i=0;i<list.length;i++)
    list[i]["name"] = filterArtistName(list[i]["name"]);

  var prevFc = null;

  for (var i=0;i<list.length;i++) {
    var name = list[i]["name"];
    var fc = name.charAt(0);
    if (fc != undefined) { 
      if (fc != prevFc) {
        if (inittype == "shadow") {
          if (!artistShortcuts_shadow) {
            artistShortcuts_shadow = new Array();
          }
          artistShortcuts_shadow.push(new Array());
          artistShortcuts_shadow[artistShortcuts_shadow.length-1]['_ui_index'] = 0;
        } else {
          if (!artistShortcuts) {
            artistShortcuts = new Array();
          }
          artistShortcuts.push(new Array());
          artistShortcuts[artistShortcuts.length-1]['_ui_index'] = 0;
        }
        prevFc = fc;
      } 
      if (inittype == "shadow") {
        artistShortcuts_shadow[artistShortcuts_shadow.length-1].push(list[i]);
      } else {
        artistShortcuts[artistShortcuts.length-1].push(list[i]);
      }
    }
  }

  list = null;
}


function adjustArtistShortcutPosition(offset) {
  artistShortcutLeftPosition += offset;

  if (artistShortcutLeftPosition < 0)
    artistShortcutLeftPosition = 0;
}

function getArtistShortcutCharacter(offsetToCurrentPosition) {
  return getArtistName(fixOffset(offsetToCurrentPosition)).substring(0,1).toLowerCase();
}

function getArtistShortcutCount() {
  return artistShortcuts ? artistShortcuts.length : 0;
}

function getShortcutArtists(index) {
  return artistShortcuts ? artistShortcuts[index] : null;
}

function getArtistShortcutUiIndex(index) {
  if (!artistShortcuts) {
    return 0;
  }

  if (index == undefined) {
    index = currentShortcutIndex();
  }
  var index = fixOffset(index);

  var shortcutArray = artistShortcuts[index];
  if (shortcutArray == undefined) {
    console.log("ERROR: object is undefined");
    return 0;
  }
  var obj = shortcutArray['_ui_index'];
  if (obj == undefined) {
    console.log("ERROR: object is undefined");
    return 0;
  }

  return obj;
}

/**
* Makes sure the offset is valid number. Defaults to zero (0).
*/
function fixOffset(offset) {
  if (offset == undefined || offset == null)
    return 0;

  return parseInt(offset);
}

function getArtistCount(index) {
  if (index == undefined) {
    index = currentShortcutIndex();
  }
  return artistShortcuts[fixOffset(index)].length;
}

function getArtist(offsetToCurrentPosition, artistIndex) {
  artistIndex = fixOffset(artistIndex);
  offsetToCurrentPosition = fixOffset(offsetToCurrentPosition);

  var index = artistShortcutLPos + offsetToCurrentPosition;

  return artistShortcuts[index][artistIndex];
}

function getArtistName(offsetToCurrentPosition, artistIndex) {
  return getArtist(offsetToCurrentPosition, artistIndex)["name"];
}

function getArtistId(offsetToCurrentPosition, artistIndex) {
  return getArtist(offsetToCurrentPosition, artistIndex)["id"];
}

function renderArtistPage(renderHint) {
  renderPage(document.getElementById("artists_tile"), renderHint);
}

function renderAlbumPage(renderHint) {
  renderPage(document.getElementById("artist_albums_page"), renderHint);
}

function rotateArtistList(ignoreRotate) {
  var curIdx = currentShortcutIndex();
  var uiIndex = getArtistShortcutUiIndex(); 
  if (ignoreRotate != undefined && ignoreRotate === false) {
  } else {
    uiIndex += 6;
  }

  var wrapped = parseInt(uiIndex - getArtistCount(curIdx));
  if (wrapped >= 0)
    uiIndex = 0;
  
  artistShortcuts[curIdx]['_ui_index'] = uiIndex;
  renderView("artists_container", {"renderHint": "artistlistOnly"});
}

function updateShortcutVisiblePageText(object) {
  if (!object) {
    var curIdx = currentShortcutIndex();
    object = $("div[data-shortcut-index=" + curIdx + "]");
    if (!object) {
      return;
    }
  }
  var totalArtists = getArtistCount();
  var currentArtistIndex = getArtistShortcutUiIndex();

  if (totalArtists > 6) {
    var totalPages = Math.ceil(totalArtists / 6);
    var currentPage = (currentArtistIndex / 6) + 1;
    var textObject = $(object).children(".artist_shortcut_hili_small_text")[0];
    if (textObject != undefined) {
      $(textObject).css("display", "block");
      textObject.innerHTML = "<b>" + currentPage + "</b> / " + totalPages;
    }
  }
}

/**
* This method is invoked when User "presses" artist shortcut (A,B,C,..).
*/
function selectArtistShortcut(object) {
  if (!object) {
    return;
  }

  var index = parseInt(object.getAttribute("data-shortcut-index"));

  $(".artist_shortcut_hili_small_text").css("display", "none");

  if ($(object).hasClass("artist_shortcut_hili")) {
    rotateArtistList();
  } else {
    $(".artist_shortcut").removeClass("artist_shortcut_hili");
    $(object).addClass("artist_shortcut_hili");
    artistShortcutOffset = index % artistShortcutVisibleItems; 
    renderView("artists_container", {"renderHint": "artistlistOnly"});
  }
  updateShortcutVisiblePageText(object); 
}

function tunaDaemonConnectionEstablished() {
}

function tunaDaemonConnectionClosed() {
  $("#connectionlost").removeClass("hidden");
}

function doInitialize(loadtype) {
    tunaPlayer.getAllArtists(function(json) {
      if (json["status"] == "OK") {
        $("#waitamoment").addClass("hidden"); 
        if (loadtype == "shadow") {
          allArtists_shadow = json["args"]["items"];
          initArtistShortcuts(allArtists_shadow, loadtype); 
        } else {
          allArtists = json["args"]["items"];
          initArtistShortcuts(allArtists, loadtype);
        }
      } else {
        $("#indexingstatus").html("<center>Sorry. Error occured.</center>");
        console.log("ERROR: Response: " + JSON.stringify(json));
      }
    });

    tunaPlayer.getRadioStations(function(json) {
      if (json["status"] == "OK") {
        if (loadtype == "shadow") {
          radioStations_shadow = json["args"]["items"];
        } else {
          radioStations = json["args"]["items"];
        }
      } else {
        radioStations = new Array();
      }
    });
}

function selectUserProfile(profiles, callback) {
  userProfileList = profiles;
  console.log("AVAILABLE PROFILES: " + JSON.stringify(profiles));

  if (userProfileList.length < 2) {
    callback();
  } else {
    userProfileSelected(profiles[0], callback);
    // TODO: Move to the appro    
  }
// Fallback
}

function userProfileSelected(profilename, callback) {
  tunaPlayer.setUserProfile(profilename);
  callback();
  // TODO. Move to root view!
}

function processStartupProgress(percents, loadtype) {

  console.log("STARTUP-PROGRESS: " + percents);

  percens = parseInt(percents);

  if (percents >= 100) {
      tunaPlayer.getUserProfiles(function(json) {
        if (json["status"] == "OK") {
          var profiles = json["args"]["profilelist"];
          selectUserProfile(profiles, function() { doInitialize(loadtype); });
        }
      });
  } else { 
    var opacity_value = 1.4 - percents / 99;
    if (opacity_value > 1.0) opacity_value = 1.0;
    $("#waitamoment").css("opacity", opacity_value);
    $("#indexingstatus").html("<center>indexing.." + percents + "\%" + "</center>");
  }
}

function processDatabaseChanged() {
  console.log("processDatabaseChanged");
  processStartupProgress(100, "shadow");

  if (isForegroundView("recent_albums_container")) {
    loadViewContent('root', 'recent_albums_container', null, function() { 
     renderView('recent_albums_container'); 
    });
  }
}

function updateChangedAlbumToLocalCache(json) {
  var albumId = json["id"];
  if (albumId == undefined)
    return;

  /* Update the cached artist albums.. */
  if (artistAlbums != undefined && artistAlbums != null && artistAlbums.length > 0) {
    if (artistAlbums[0]["artist.id"] != json["artist.id"]) {
      console.log("change in non-visible artist " + json["artist.id"] + " (Your: " + artistAlbums[0]["artist.id"] + ")");
      return;
    }
    
    for (var i=0;i<artistAlbums.length;i++) {
      if (artistAlbums[i]["id"] == albumId) {
        console.log("Updated to local cache");
        artistAlbums[i] = json;
      }
    }
  }
  /* Update the currently playing album if equals */
  if (currentAlbum != undefined && currentAlbum != null) {
    if (currentAlbum["id"] == albumId) {
      currentAlbum = json;
    }
  }
}


function processAlbumChanged(json) {
  /* Update locally cached album object */
  updateChangedAlbumToLocalCache(json);

  /* Update also UI directly, in case it is visible at this moment already */
  
  var art = json["album.artl"] != undefined ? json["album.artl"] : json["album.arts"];
  var id = json["id"];
  if (id.length > 0) {
    console.log("Updating UI for album " + id + " to have image " + art);
    /* Update the single album page to contain the "up-to-date" albumart */

    /* TOOD: Update also the locally cached stuff here so that We get up-to-date information when required. */
    $("img").each(function(index, object) {
      myid = $(object).attr("data-album-id");
      if (myid == id) {
        if (art.length > 0) {
          $(object).attr("src", art);
        } else {
          $(object).removeAttr("src");
        }
      }
    });
  }
}


function compileTemplates() {
  var docname = "tunaplayer.tmpl";
  if (isMobile()) {
    docname = "tunaplayer_n9.tmpl";
  }
  $.get(docname, function(document) {

    var tls = document.split("_TUNA_BEGIN_TEMPLATE");
    for (var i=0;i<tls.length;i++) {
      var contentAndName = tls[i].trim().split("_TUNA_END_TEMPLATE=");
      if (contentAndName.length == 2) {
        var content = contentAndName[0].trim();
        var name = contentAndName[1].trim();
        if (name.length > 0 && content.length > 0) {
          try {
            templates[name] = $.jqotec(content);
            console.log("COMPILED TEMPLATE: " + name);
          } catch (e) {
            console.log("COMPILATION ERROR: " + name);
            console.log("Exception: " + e.toString());
            console.log("SOURCE: " + content);
          }
        }
      }
    }
  });
}

function connectToDaemon() {

  tunaPlayer.onOpened = tunaDaemonConnectionEstablished;
  tunaPlayer.onClosed = tunaDaemonConnectionClosed;

  tunaPlayer.onAlbumArtSearchItem = handleAlbumArtDownloaded;
  tunaPlayer.onAlbumArtSearchComplete = handleSearchAlbumArtComplete;

  tunaPlayer.onPlaybackControlsChanged = playerUpdateButtons;
  tunaPlayer.onPlaybackTrackChanged = playerUpdatePlaybackTrack;
  tunaPlayer.onPlaybackAlbumChanged = playerUpdatePlaybackAlbum;
  tunaPlayer.onPlaybackPositionChanged = playerUpdatePlaybackPosition;

  tunaPlayer.onCurrentPlaylistChanged = playerUpdateCurrentPlaylist;

  tunaPlayer.onStartupProgress = processStartupProgress;

  /* This event is received when information regarding an album changes. Album does not need to playing at that time. */
  tunaPlayer.onAlbumChanged = processAlbumChanged;

  tunaPlayer.onVolumeChanged = processVolumeChanged;

  tunaPlayer.onDatabaseChanged = processDatabaseChanged;

  if (!tunaPlayer.open(document.URL)) {
      $("#notsupported").removeClass("hidden");
  }
  compileTemplates();
}

function processVolumeChanged(percents) {
  if (percents == undefined || percents == null) {
    percents = tunaPlayer.cachedVolumeLevel;
    if (percents == undefined || percents == null) {
      return;
    }
  }
  console.log("process_volume_changed: " + percents);
  playerUpdateVolumeLevel(percents);
}

function playerSetVolume(level) {
  tunaPlayer.setVolume((level+1) * 10);
}

function playerVolumeAdjust(dir) {
  percents = parseInt(tunaPlayer.cachedVolumeLevel);
  if (percents < 0) {
    return;
  }
  if (dir == "up")
    percents += 10;
  else
    percents -= 10;

  console.log("Setting volume to: " + percents);
  tunaPlayer.setVolume(percents);
}

function playerUpdateVolumeLevel(volume) {
  if (!playerOpened()) {
    return;
  }

  volume = parseInt(volume);
  volume = Math.floor(volume / 10);
  console.log("volume: " + volume);
  for (var i=0;i<10;i++) {
    var id = "#player_volbar_" + i;
    if (i < volume) {
      $(id).removeClass("player_volbar_hidden");
      $(id).addClass("player_volbar_visible");
    } else {
      $(id).addClass("player_volbar_hidden");
    }
  }
}

/**
* Converts a second value to more descriptive representation
* that can be shown in UI.
*/
function age2Text(age) {
  age = parseInt(age);
  if (age < (60 * 60 * 12)) {
    return "today";
  } else if (age < (60 * 60 * 24 * 2)) {
    return "yesterday";
  } else if (age < (60 * 60 * 24 * 7)) {
    return "less than week ago";
  }
  return "more than week ago";
}

/**
* Object showing notification dialogs on top-right corner
* of the viewport
*
*/
var note = {
  ContentTypePlaylist: 1,
  ContentTypeNowPlayling: 2,

  attach: function(elemName) {
    note.element = document.getElementById(elemName);
  },

  showNowPlaying: function(json) {
    var noteS = "";
    if (json["name"] && json["album.artist.name"]) {
      noteS = "<small><i>Now playing: </i></small><br>" + "<b>" + json["name"].toLowerCase() + "</b> - " + json["album.artist.name"].toLowerCase()
    } else if (json["name"]) {
      noteS = "<small><i>Now playing: </i></small><br>" + "<b>" + json["name"].toLowerCase() + "</b>";
    }
    if (noteS.length > 0) {
      note.show(noteS, true);
    }
  },

  show: function(text, clear) {
    if (clear !== undefined && clear === true) { 
      note.element.innerHTML = "";
    }

    var hadContent = note.element.innerHTML.length > 0;
    if (hadContent) {
      note.element.innerHTML += "<br>";
    }
    note.element.innerHTML += text;
    if (isMobile()) {
      $(note.element).css('top', window.pageYOffset + 30);
    }
    if (hadContent) {
      $(note.element).css('height', $(note.element).css('heigth') + 100);
    }

    $(note.element).removeClass("hidden");
    /* Will begin to show after 50ms */
    setTimeout(function() { $(note.element).css({"opacity":"0.9"}) }, 50);
    if (note.hideTimer) {
      clearTimeout(note.hideTimer);
      note.hideTimer = null;
    }
    $(note.element).css({"opacity":"1"});
    note.hideTimer = setTimeout(function() { note.element.innerHTML = ""; note.hide(3500); }, 3500);
  },

  hide: function(text) {
    $(note.element).css({"opacity":"0"});
    setTimeout(function(){note.element.innerHTML = ""; $(note.element).addClass("hidden");}, 1000);
  },
  element: null,
  hideTimer: null
}


/*
 * This code is based on (from: https://raw.github.com/bradbirdsall/Swipe/master/swipe.js) although
 * mostly rewritten to fit new use cases...
 * -------------------------------------------------
 * Swipe 1.0
 *
 * Brad Birdsall, Prime
 * Copyright 2011, Licensed GPL & MIT
 * -------------------------------------------------
 *
*/

window.Swipe = function(element, callback) {
  var _this = this;

  this.swipeAllowedTimer = null;
  this.callback = callback;
  this.element = element;
  this.callbackTimer = null;

  // trigger initialization
  this.setup();

  // add event listeners
  if (this.element.addEventListener) {
    this.element.addEventListener('touchstart', this, false);
    this.element.addEventListener('touchmove', this, false);
    this.element.addEventListener('touchend', this, false);
  }
};

Swipe.prototype = {

  setup: function() {
  },

  handleEvent: function(e) {
    switch (e.type) {
      case 'touchstart': this.onTouchStart(e); break;
      case 'touchmove': this.onTouchMove(e); break;
      case 'touchend': this.onTouchEnd(e); break;
    }
  },

  onTouchStart: function(e) {
    this.start = {
      // get touch coordinates for delta calculations in onTouchMove
      pageX: e.touches[0].pageX,
      pageY: e.touches[0].pageY,

      // set initial timestamp of touch sequence
      time: Number( new Date() )
    };

    // used for testing first onTouchMove event
    this.isScrolling = undefined;
    this.deltaX = 0;
  },

  onTouchMove: function(e) {
    // ensure swiping with one touch and not pinching
    if(e.touches.length > 1 || e.scale && e.scale !== 1) return;

    var duration = Number(new Date()) - this.start.time;

    this.deltaX = e.touches[0].pageX - this.start.pageX;
    // determine if scrolling test has run - one time test
    if ( typeof this.isScrolling == 'undefined') {
      this.isScrolling = !!( this.isScrolling || Math.abs(this.deltaX) < Math.abs(e.touches[0].pageY - this.start.pageY) );
    }

    // if user is not trying to scroll vertically -> disable the default event. Otherwise pass it through.
    if (!this.isScrolling) {
      e.preventDefault();
    }
  },

  onTouchEnd: function(e) {
    // determine if slide attempt triggers next/prev slide
    var duration = Number(new Date()) - this.start.time;
    var moveDelta = Math.abs(this.deltaX);

    var validSlide = duration < 350 && moveDelta > 40 && this.isScrolling === false; 

    if (validSlide) {
      this.isScrolling = undefined;
      var md = this.deltaX < 0 ? "move.next" : "move.previous";
      if (!this.swipeAllowedTimer) {
        this.callback(md);
        this.swipeAllowedTimer = setTimeout(function() { this.swipeAllowedTimer = null }, 1000);
      }
    }
  }
};

</script>

  <body onload="connectToDaemon(); note.attach('notificationdialog');" onkeypress="handleKeyPress(event);" style="background: black; z-index:1;">
    <div class="playercontainer" id="root">

      <div id=radio_launcher class="tile_00 tile_closed"  onclick="openView('root', 'radio_container');">
        <div class="tile_closed_inner"><center>radio</center></div>
      </div>

      <div id=artists_launcher class="tile_10 tile_closed"  onclick="openView('root', 'artists_container');">
        <div class="tile_closed_inner"><center>collection</center></div>
      </div>

      <div id=player_launcher class="tile_01 tile_closed"  onclick="openView('root', 'player_container');">
        <div class="tile_closed_inner"><center>player</center></div>
      </div>

      <div id=playrandom_launcher class="tile_11 tile_closed"  onclick="tunaPlayer.playPlaylist('Random tracks'); openView('root', 'player_container');">
        <div class="tile_closed_inner"><center>random</center></div>
      </div>

      <div id=search_launcher class="tile_12 tile_closed"  onclick="openView('root', 'search_container');">
        <div class="tile_closed_inner"><center>search</center></div>
      </div>

      <div id=recent_albums_launcher class="tile_02 tile_closed"  onclick="openView('root', 'recent_albums_container');">
        <div class="tile_closed_inner"><center>new</center></div>
      </div>

      <div id="radio_container" class="topleft div_hidden">
      </div>

      <div id=artists_container class="topleft div_hidden">              
      </div>

      <div id=recent_albums_container class="topleft div_hidden">
      </div>

      <div id=popular_albums_container class="topleft div_hidden">
      </div>

      <div id=artist_albums_container class="topleft div_hidden">
      </div>

      <div id="search_album_arts" class="topleft div_hidden">
      </div>

      <div id="artist_single_album_container" class="topleft div_hidden">
      </div>

      <div id="player_container" class="topleft div_hidden">
      </div>

      <div id="search_container" class="topleft div_hidden">
      </div>

      <div id="player_current_playlist" class="topleft div_hidden">
      </div>

      <div id="playlist_container" class="topleft div_hidden">
      </div>

      <div id="userprofileselect_container" class="topleft div_hidden">

      </div>

    </div>

    <div id=waitamoment onclick=";"><br>
      <p id=tunaversion>
        <center>tunaPlayer</center><br><small><center>2012 (c) Jarmo Kuronen</small></center>
      </p>
      <p id=indexingstatus></p>
    </div>

    <div id=connectionlost class="hidden" onclick=";"><br>
     <p><center>connection closed</center></p>
    </div>

    <div id=error class="hidden" onclick=";"><br>
     <p><center>error occured - kind of..</center></p>
    </div>

    <div id=notsupported class="hidden" onclick=";"><br>
     <p><center>Your browser is not supported</center></p>
    </div>

    <div id=notificationdialog class="notification_dialog hidden" onclick="note.hide();">    
    </div>

  </body>
</html>

